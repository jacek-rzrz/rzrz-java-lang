package rzrz.java.lang;

import java.util.Objects;

import rzrz.java.lang.Functions.*;

/**
 *  AUTOGENERATED FILE: DO NOT MODIFY
 *  @see src-gen/generate.js
 *  @author Jacek Rzeniewicz
 */
public final class Tuples {

	/**
	 * Top-level interface implemented by all tuples.
	 *
	 * <p>Defines static factory methods for instantiating tuples, e.g.
	 * <pre>
	 * {@code
	 * Tuple2&lt;Integer, String&gt; tup = Tuple.of(3, "Hello");
	 * }
	 * </pre>
	 */
	public interface Tuple {

		/**
		 * Factory method for creating Tuple2 instances.
		 */
		static <T1, T2> Tuple2<T1, T2> of(T1 $1, T2 $2) {
			return new Tuple2($1, $2);
		}

		/**
		 * Factory method for creating Tuple3 instances.
		 */
		static <T1, T2, T3> Tuple3<T1, T2, T3> of(T1 $1, T2 $2, T3 $3) {
			return new Tuple3($1, $2, $3);
		}

		/**
		 * Factory method for creating Tuple4 instances.
		 */
		static <T1, T2, T3, T4> Tuple4<T1, T2, T3, T4> of(T1 $1, T2 $2, T3 $3, T4 $4) {
			return new Tuple4($1, $2, $3, $4);
		}


	}


	/**
	 * Tuple of arity 2.
	 *
	 * <p>Objects of this class are immutable.
	 */
	public static class Tuple2<T1, T2> implements Tuple {

		/**
		 * Element #1 (1-based indexing)
		 */
		public final T1 $1;
		/**
		 * Element #2 (1-based indexing)
		 */
		public final T2 $2;

		/**
		 * Creates a new instance.
		 *
		 * <p>See also Tuples.of() for more convenient Tuple creation
		 * @see Tuple#of
		 */
		public Tuple2(T1 $1, T2 $2) {
			this.$1 = $1;
			this.$2 = $2;
		}

		public <T3> Tuple3<T1, T2, T3> append(T3 $3) {
			return new Tuple3<>($1, $2, $3);
		}

		public <T0> Tuple3<T0, T1, T2> prepend (T0 $0) {
			return new Tuple3<>($0, $1, $2);
		}



		public <U> Tuple3<T1, U, T2> insert2(U $) {
			return new Tuple3<>($1, $, $2);
		}



		public <T3, T4> Tuple4<T1, T2, T3, T4> concat(Tuple2<T3, T4> other) {
			return new Tuple4<>($1, $2, other.$1, other.$2);
		}


		public <U> U map(Func2<T1, T2, U> mapper) {
			return mapper.call($1, $2);
		}

		public <U, E extends Throwable> U mapThrowing(Func2ThrowsT<T1, T2, U, E> mapper) throws E {
			return mapper.call($1, $2);
		}

		public Tuple2<T1, T2> consume(Action2<T1, T2> callable) {
			callable.call($1, $2);
			return this;
		}

		public <E extends Throwable> Tuple2<T1, T2> consumeThrowing(Action2ThrowsT<T1, T2, E> callable) throws E {
			callable.call($1, $2);
			return this;
		}

		@Override
		public String toString() {
			return "(" + $1 + ", " + $2 + ")";
		}

		@Override
		public boolean equals(Object obj) {
			if(this == obj) return true;
			if(!(this instanceof Tuple2)) return false;
			Tuple2<T1, T2> other =
				(Tuple2<T1, T2>) obj;
			if(!Objects.equals($1, other.$1)) return false;
			if(!Objects.equals($2, other.$2)) return false;
			return true;
		}

		@Override
		public int hashCode() {
			return Objects.hash($1, $2);
		}
	}


	/**
	 * Tuple of arity 3.
	 *
	 * <p>Objects of this class are immutable.
	 */
	public static class Tuple3<T1, T2, T3> implements Tuple {

		/**
		 * Element #1 (1-based indexing)
		 */
		public final T1 $1;
		/**
		 * Element #2 (1-based indexing)
		 */
		public final T2 $2;
		/**
		 * Element #3 (1-based indexing)
		 */
		public final T3 $3;

		/**
		 * Creates a new instance.
		 *
		 * <p>See also Tuples.of() for more convenient Tuple creation
		 * @see Tuple#of
		 */
		public Tuple3(T1 $1, T2 $2, T3 $3) {
			this.$1 = $1;
			this.$2 = $2;
			this.$3 = $3;
		}

		public <T4> Tuple4<T1, T2, T3, T4> append(T4 $4) {
			return new Tuple4<>($1, $2, $3, $4);
		}

		public <T0> Tuple4<T0, T1, T2, T3> prepend (T0 $0) {
			return new Tuple4<>($0, $1, $2, $3);
		}

		public Tuple2<T2, T3> skip1() {
			return new Tuple2<>($2, $3);
		}


		public Tuple2<T1, T2> take2() {
			return new Tuple2<>($1, $2);
		}


		public <U> Tuple4<T1, U, T2, T3> insert2(U $) {
			return new Tuple4<>($1, $, $2, $3);
		}

		public <U> Tuple4<T1, T2, U, T3> insert3(U $) {
			return new Tuple4<>($1, $2, $, $3);
		}


		public Tuple2<T1, T3> remove2() {
			return new Tuple2<>($1, $3);
		}



		public <U> U map(Func3<T1, T2, T3, U> mapper) {
			return mapper.call($1, $2, $3);
		}

		public <U, E extends Throwable> U mapThrowing(Func3ThrowsT<T1, T2, T3, U, E> mapper) throws E {
			return mapper.call($1, $2, $3);
		}

		public Tuple3<T1, T2, T3> consume(Action3<T1, T2, T3> callable) {
			callable.call($1, $2, $3);
			return this;
		}

		public <E extends Throwable> Tuple3<T1, T2, T3> consumeThrowing(Action3ThrowsT<T1, T2, T3, E> callable) throws E {
			callable.call($1, $2, $3);
			return this;
		}

		@Override
		public String toString() {
			return "(" + $1 + ", " + $2 + ", " + $3 + ")";
		}

		@Override
		public boolean equals(Object obj) {
			if(this == obj) return true;
			if(!(this instanceof Tuple3)) return false;
			Tuple3<T1, T2, T3> other =
				(Tuple3<T1, T2, T3>) obj;
			if(!Objects.equals($1, other.$1)) return false;
			if(!Objects.equals($2, other.$2)) return false;
			if(!Objects.equals($3, other.$3)) return false;
			return true;
		}

		@Override
		public int hashCode() {
			return Objects.hash($1, $2, $3);
		}
	}


	/**
	 * Tuple of arity 4.
	 *
	 * <p>Objects of this class are immutable.
	 */
	public static class Tuple4<T1, T2, T3, T4> implements Tuple {

		/**
		 * Element #1 (1-based indexing)
		 */
		public final T1 $1;
		/**
		 * Element #2 (1-based indexing)
		 */
		public final T2 $2;
		/**
		 * Element #3 (1-based indexing)
		 */
		public final T3 $3;
		/**
		 * Element #4 (1-based indexing)
		 */
		public final T4 $4;

		/**
		 * Creates a new instance.
		 *
		 * <p>See also Tuples.of() for more convenient Tuple creation
		 * @see Tuple#of
		 */
		public Tuple4(T1 $1, T2 $2, T3 $3, T4 $4) {
			this.$1 = $1;
			this.$2 = $2;
			this.$3 = $3;
			this.$4 = $4;
		}


		public Tuple3<T2, T3, T4> skip1() {
			return new Tuple3<>($2, $3, $4);
		}

		public Tuple2<T3, T4> skip2() {
			return new Tuple2<>($3, $4);
		}


		public Tuple2<T1, T2> take2() {
			return new Tuple2<>($1, $2);
		}

		public Tuple3<T1, T2, T3> take3() {
			return new Tuple3<>($1, $2, $3);
		}



		public Tuple3<T1, T3, T4> remove2() {
			return new Tuple3<>($1, $3, $4);
		}

		public Tuple3<T1, T2, T4> remove3() {
			return new Tuple3<>($1, $2, $4);
		}



		public <U> U map(Func4<T1, T2, T3, T4, U> mapper) {
			return mapper.call($1, $2, $3, $4);
		}

		public <U, E extends Throwable> U mapThrowing(Func4ThrowsT<T1, T2, T3, T4, U, E> mapper) throws E {
			return mapper.call($1, $2, $3, $4);
		}

		public Tuple4<T1, T2, T3, T4> consume(Action4<T1, T2, T3, T4> callable) {
			callable.call($1, $2, $3, $4);
			return this;
		}

		public <E extends Throwable> Tuple4<T1, T2, T3, T4> consumeThrowing(Action4ThrowsT<T1, T2, T3, T4, E> callable) throws E {
			callable.call($1, $2, $3, $4);
			return this;
		}

		@Override
		public String toString() {
			return "(" + $1 + ", " + $2 + ", " + $3 + ", " + $4 + ")";
		}

		@Override
		public boolean equals(Object obj) {
			if(this == obj) return true;
			if(!(this instanceof Tuple4)) return false;
			Tuple4<T1, T2, T3, T4> other =
				(Tuple4<T1, T2, T3, T4>) obj;
			if(!Objects.equals($1, other.$1)) return false;
			if(!Objects.equals($2, other.$2)) return false;
			if(!Objects.equals($3, other.$3)) return false;
			if(!Objects.equals($4, other.$4)) return false;
			return true;
		}

		@Override
		public int hashCode() {
			return Objects.hash($1, $2, $3, $4);
		}
	}

}
